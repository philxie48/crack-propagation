#!/usr/bin/env python3
"""
Newton-Raphson FEM Crack Propagation Simulation
- Uses Newton-Raphson iteration to solve the coupled nonlinear system
- Implements residual-based formulation with convergence checking
- Comparison version to the direct stiffness matrix approach
"""

import numpy as np
import matplotlib
matplotlib.use('Agg')  # Use non-interactive backend for multiprocessing compatibility
import matplotlib.pyplot as plt
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve
import time
import os
try:
    from fem_parallel_utils import ParallelConfig, compute_residuals_parallel
    PARALLEL_AVAILABLE = True
except ImportError:
    PARALLEL_AVAILABLE = False
    print("Warning: Parallel computing not available. Install fem_parallel_utils.py for multi-core support.")

class FEMCrackSimulationNewtonRaphson:
    def __init__(self, mesh_file='robust_crack.npz'):
        """Initialize Newton-Raphson FEM crack propagation simulation"""
        
        # Load mesh data
        if mesh_file.endswith('.npz'):
            mesh_data = np.load(mesh_file)
            self.nodes = mesh_data['nodes']
            self.elements = mesh_data['triangles']
        else:
            print(f"Error: Expected .npz file, got {mesh_file}")
            print("Please use the robust mesh generated by robust_crack_mesh.py")
            return
            
        self.n_nodes = len(self.nodes)
        self.n_elements = len(self.elements)
        
        print(f"Loaded robust mesh: {self.n_nodes} nodes, {self.n_elements} elements")
        
        # Material properties (from fem_em.md)
        self.E = 210e9  # Pa (210 GPa)
        self.nu = 0.3   # Poisson's ratio
        self.rho = 7.38e3  # kg/m³
        self.g = 9.81   # m/s²
        
        # Body force (from fem_em.md: ρg = 72.4×10³ N/m³)
        self.body_force = np.array([0, -72.4e3])  # N/m³ downward
        
        # Phase field properties (from fem_em.md)
        self.Gc = 4000  # N/m (fracture energy) - updated value
        self.l0 = 1.25e-5  # m (length scale)
        self.k = 1e-6  # Small regularization parameter
        
        # Penalty method parameters (from fem_em.md)
        self.eta = 4e6  # Penalty parameter
        self.m = 2      # Penalty exponent
        
        # Newton-Raphson parameters
        self.max_iterations = 20      # Increased for better convergence
        self.tolerance_abs = 1e-6     # Absolute tolerance
        self.tolerance_rel = 1e-8     # Relative tolerance
        
        # Parallel computing parameters
        self.use_parallel = PARALLEL_AVAILABLE  # Enable if available
        self.n_cores = 12  # Auto-detect optimal number (or set manually, e.g., self.n_cores = 8)
        
        # MANUAL OVERRIDE: Uncomment and set to manually choose core count
        # self.n_cores = 8  # Example: use 8 cores
        # self.n_cores = 12  # Example: use 12 cores
        # self.n_cores = 16  # Example: use 16 cores
        
        if self.use_parallel:
            self.parallel_config = ParallelConfig(n_cores=self.n_cores, verbose=True)
            self.n_cores = self.parallel_config.n_cores
        
        # Time parameters
        self.dt = 1   # s (time step)  
        self.t_final = 3000.0  # s (reduced for Newton-Raphson testing)
        self.n_steps = int(self.t_final / self.dt)
        self.save_interval = 2  # Save every 5 seconds
        
        # Solution fields
        self.u = np.zeros(2 * self.n_nodes)  # Displacement [ux1, uy1, ux2, uy2, ...]
        self.phi = np.zeros(self.n_nodes)    # Phase field - all zeros since crack void is in mesh
        self.phi_old = np.zeros(self.n_nodes)  # Previous time step phase field
        
        # Initialize phase field (all zeros since crack void is already in mesh geometry)
        self.initialize_phase_field()
        
        # Constitutive matrix (plane strain)
        self.D = self.compute_constitutive_matrix()
        
        # Find boundary nodes
        self.find_boundary_nodes()
        
        print("Newton-Raphson FEM simulation initialized successfully")
        print(f"Initial phase field: all φ = {np.max(self.phi):.1f} (crack void in mesh geometry)")
        print(f"Newton-Raphson parameters: max_iter={self.max_iterations}, tol_abs={self.tolerance_abs}, tol_rel={self.tolerance_rel}")
        if self.use_parallel:
            print(f"Parallel computing: ENABLED ({self.n_cores} cores)")
        else:
            print(f"Parallel computing: DISABLED (single-core mode)")
        
        # Print critical parameters for crack propagation
        driving_threshold = self.Gc / (2 * self.l0)
        print(f"Critical strain energy density for propagation: {driving_threshold:.2e} J/m³")
        print(f"Material parameters: Gc={self.Gc} N/m, l₀={self.l0*1e6:.1f} μm")
        print(f"Phase field parameters: k={self.k}, η={self.eta:.0e}, m={self.m}")
        print(f"Body force magnitude: {np.linalg.norm(self.body_force):.1e} N/m³")
    
    def compute_constitutive_matrix(self):
        """Compute plane strain constitutive matrix (from fem_em.md)"""
        factor = self.E * (1 - self.nu) / ((1 + self.nu) * (1 - 2 * self.nu))
        D = np.array([
            [1.0, self.nu/(1-self.nu), 0],
            [self.nu/(1-self.nu), 1.0, 0],
            [0, 0, (1-2*self.nu)/(2*(1-self.nu))]
        ]) * factor
        return D
    
    def initialize_phase_field(self):
        """Initialize phase field - all zeros since crack void is in mesh geometry"""
        # Since the crack void is already represented in the mesh geometry,
        # we initialize φ = 0 everywhere (intact material)
        # The crack propagation will be driven by mechanical loading
        self.phi = np.zeros(self.n_nodes)
        self.phi_old = self.phi.copy()
        print("Phase field initialized: φ = 0 everywhere (crack void in mesh geometry)")
    
    def find_boundary_nodes(self):
        """Find boundary nodes for applying boundary conditions - FIXED VERSION"""
        # Use consistent tolerance with working version - NOT too tight
        tol = 1e-9  # Same as working version, NOT 1e-12
        
        # Find domain boundaries - same logic as working version
        y_coords = self.nodes[:, 1]
        x_coords = self.nodes[:, 0]
        
        # Bottom boundary: y = 0 
        self.bottom_nodes = np.where(y_coords < tol)[0]  # Same as working version
        
        # Top boundary: y = 1e-3 
        self.top_nodes = np.where(y_coords > (1e-3 - tol))[0]  # Same as working version
        
        # Left boundary: x = 0 
        self.left_nodes = np.where(x_coords < tol)[0]  # Same as working version
        
        # Right boundary: x = 1e-3 
        self.right_nodes = np.where(x_coords > (1e-3 - tol))[0]  # Same as working version
        
        print(f"Boundary nodes: bottom={len(self.bottom_nodes)}, top={len(self.top_nodes)}, "
              f"left={len(self.left_nodes)}, right={len(self.right_nodes)}")
        
        # Debug: Check the y-coordinates of top nodes
        if len(self.top_nodes) > 0:
            top_y_coords = y_coords[self.top_nodes]
            print(f"Top nodes y-coordinates: min={np.min(top_y_coords)*1e3:.6f}mm, "
                  f"max={np.max(top_y_coords)*1e3:.6f}mm")
            print(f"Y-coordinate spread: {(np.max(top_y_coords) - np.min(top_y_coords))*1e6:.3f}μm")
            
            # Check if we have nodes at different y-levels (which would cause the sharp transition)
            unique_y = np.unique(np.round(top_y_coords * 1e9))  # Round to nanometer precision
            if len(unique_y) > 1:
                print(f"⚠️  WARNING: Top nodes are at {len(unique_y)} different y-levels!")
                print(f"   This will create sharp displacement transitions!")
            else:
                print(f"✓ All top nodes are at the same y-level")
    
    def shape_functions(self, xi, eta):
        """Linear triangle shape functions and derivatives"""
        N = np.array([1 - xi - eta, xi, eta])
        
        # Shape function derivatives in natural coordinates
        dN_dxi = np.array([-1, 1, 0])
        dN_deta = np.array([-1, 0, 1])
        
        return N, dN_dxi, dN_deta
    
    def compute_B_matrices(self, element_nodes):
        """Compute B matrices for element"""
        # Element coordinates
        x1, y1 = element_nodes[0]
        x2, y2 = element_nodes[1]
        x3, y3 = element_nodes[2]
        
        # Jacobian matrix
        J = np.array([
            [x2 - x1, x3 - x1],
            [y2 - y1, y3 - y1]
        ])
        
        det_J = np.linalg.det(J)
        if abs(det_J) < 1e-12:
            print(f"Warning: Small Jacobian determinant: {det_J}")
            
        J_inv = np.linalg.inv(J)
        
        # Shape function derivatives in physical coordinates
        dN_dx = J_inv @ np.array([[-1, 1, 0], [-1, 0, 1]])
        
        # B matrix for displacement (strain-displacement)
        B_u = np.zeros((3, 6))  # 3 strains, 6 DOFs (2 per node)
        for i in range(3):
            B_u[0, 2*i] = dN_dx[0, i]      # ∂N_i/∂x for εxx
            B_u[1, 2*i+1] = dN_dx[1, i]    # ∂N_i/∂y for εyy
            B_u[2, 2*i] = dN_dx[1, i]      # ∂N_i/∂y for γxy
            B_u[2, 2*i+1] = dN_dx[0, i]    # ∂N_i/∂x for γxy
        
        # B matrix for phase field (gradient)
        B_phi = np.zeros((2, 3))  # 2 gradients, 3 nodes
        B_phi[0, :] = dN_dx[0, :]  # ∂N_i/∂x
        B_phi[1, :] = dN_dx[1, :]  # ∂N_i/∂y
        
        return B_u, B_phi, det_J
    
    def compute_elastic_energy_density(self, strain):
        """Compute positive part of elastic energy density"""
        # Compute stress
        stress = self.D @ strain
        
        # Elastic energy density
        psi = 0.5 * strain @ stress
        
        # Return positive part (for phase field driving force)
        return max(0, psi)
    
    def compute_strain_energy_density_field(self):
        """Compute strain energy density at all nodes"""
        strain_energy = np.zeros(self.n_nodes)
        node_count = np.zeros(self.n_nodes)
        
        for elem_id, element in enumerate(self.elements):
            element_nodes = self.nodes[element]
            
            # Get B matrix
            B_u, _, det_J = self.compute_B_matrices(element_nodes)
            
            # Element displacement
            u_elem = np.zeros(6)
            for i in range(3):
                u_elem[2*i] = self.u[int(2*element[i])]      # ux
                u_elem[2*i+1] = self.u[int(2*element[i]+1)]  # uy
            
            # Compute strain
            strain = B_u @ u_elem
            
            # Elastic energy density
            psi = self.compute_elastic_energy_density(strain)
            
            # Add to nodes (averaging)
            for i in range(3):
                strain_energy[element[i]] += psi
                node_count[element[i]] += 1
        
        # Average strain energy density at nodes
        strain_energy = np.divide(strain_energy, node_count, 
                                out=np.zeros_like(strain_energy), 
                                where=node_count!=0)
        
        return strain_energy
    
    def penalty_function(self, phi_dot):
        """Compute penalty function for irreversibility"""
        if phi_dot < 0:  # Healing attempt
            return self.eta / (self.m * self.dt) * (-phi_dot) ** self.m
        else:
            return 0
    
    def penalty_derivative(self, phi_dot):
        """Derivative of penalty function (matching backup_ele.py working implementation)"""
        if phi_dot < 0:  # Healing attempt
            # Simple working form from backup_ele.py
            return self.eta / self.dt * (-phi_dot) ** (self.m - 1)
        else:
            return 0
    
    def compute_residuals(self):
        """Compute residual vectors R_u and R_phi according to pure_mechanical.md Section 4"""
        n_dof_u = 2 * self.n_nodes
        n_dof_phi = self.n_nodes
        
        # Use parallel computation if available and beneficial
        if self.use_parallel and self.n_elements > 500:  # Only use parallel for larger problems
            R_u, R_phi = compute_residuals_parallel(
                self.nodes, self.elements, self.u, self.phi, self.phi_old,
                self.D, self.Gc, self.l0, self.k, self.eta, self.m, self.dt,
                self.body_force, n_cores=self.n_cores
            )
            return R_u, R_phi
        
        # Serial computation (original implementation)
        # Initialize residuals
        R_u = np.zeros(n_dof_u)
        R_phi = np.zeros(n_dof_phi)
        
        # Gauss points for triangle (3-point integration per pure_mechanical.md)
        gauss_points = [
            (1/6, 1/6, 1/3),      # Point 1
            (2/3, 1/6, 1/3),      # Point 2  
            (1/6, 2/3, 1/3)       # Point 3
        ]
        
        for elem_id, element in enumerate(self.elements):
            element_nodes = self.nodes[element]
            
            # Get B matrices
            B_u, B_phi, det_J = self.compute_B_matrices(element_nodes)
            area = 0.5 * abs(det_J)
            
            # Element phase field values
            phi_elem = self.phi[element]
            phi_old_elem = self.phi_old[element]
            
            # Element displacement DOF vector
            u_elem = np.zeros(6)
            for i in range(3):
                u_elem[2*i] = self.u[int(2*element[i])]      # ux
                u_elem[2*i+1] = self.u[int(2*element[i]+1)]  # uy
            
            # Compute strain (constant over linear triangle)
            strain = B_u @ u_elem
            
            # Compute stress σ = D:ε (plain stress tensor)
            stress = self.D @ strain
            
            # Compute positive elastic energy density ψ = ½ε:D:ε (per pure_mechanical.md line 227)
            psi_elem = self.compute_elastic_energy_density(strain)
            
            # Gauss integration over element
            for xi, eta, weight in gauss_points:
                N, _, _ = self.shape_functions(xi, eta)
                
                # Interpolate phase field at Gauss point
                phi_gp = N.dot(phi_elem)
                
                # Degradation function g(φ) = (1-φ)² + k (per pure_mechanical.md line 64)
                g_phi = (1 - phi_gp)**2 + self.k
                
                # =============================================================
                # MECHANICAL RESIDUAL (pure_mechanical.md Section 4.1)
                # R^u = ∫_Ω g(φ)σ:∇δu dΩ - ∫_Ω b·δu dΩ = 0
                # Discretized: R^u = ∫_Ω g(φ)(B^u)^T σ dΩ - ∫_Ω N^T b dΩ
                # =============================================================
                
                # Internal force contribution: ∫ g(φ) B^T σ dΩ
                R_u_internal = g_phi * B_u.T @ stress * area * weight
                
                # Body force contribution: ∫ N^T b dΩ (pure_mechanical.md line 67)
                # b = [0, -72.4×10³] N/m³
                R_u_body = np.zeros(6)
                for i in range(3):  # For each node in element
                    R_u_body[2*i] = self.body_force[0] * N[i] * area * weight      # x-component
                    R_u_body[2*i+1] = self.body_force[1] * N[i] * area * weight    # y-component
                
                # Mechanical residual: R^u = Internal - External
                R_u_elem = R_u_internal - R_u_body
                
                # =============================================================
                # PHASE FIELD RESIDUAL (pure_mechanical.md Section 4.2)
                # R^φ = ∫_Ω {Gc l₀ ∇φ·∇δφ + [Gc/l₀ + 2ψ(ε)] φδφ - 2ψ(ε)δφ + P(φ̇)δφ} dΩ = 0
                # Discretized form per equation 86 in pure_mechanical.md
                # =============================================================
                
                # Phase field gradient at current state
                phi_grad = B_phi @ phi_elem
                
                # Phase field time derivative (for penalty method)
                phi_dot_elem = (phi_elem - phi_old_elem) / self.dt
                
                # Term 1: Gc l₀ ∇φ·∇δφ → Gc l₀ (B^φ)^T ∇φ
                R_phi_diffusion = self.Gc * self.l0 * B_phi.T @ phi_grad * area * weight
                
                # Term 2: [Gc/l₀ + 2ψ(ε)] φδφ → [Gc/l₀ + 2ψ(ε)] N^T φ
                # This is the resistance term that opposes crack growth
                phi_at_gauss = N @ phi_elem  # φ interpolated to Gauss point
                R_phi_resistance = (self.Gc / self.l0 + 2 * psi_elem) * N * phi_at_gauss * area * weight
                
                # Term 3: -2ψ(ε)δφ → -2ψ(ε) N (driving force)
                # This is the driving force that promotes crack growth when ψ > Gc/(2l₀)
                R_phi_driving = -2 * psi_elem * N * area * weight
                
                # Term 4: Penalty term P(φ̇) for irreversibility (pure_mechanical.md lines 95-98)
                # P(φ̇) = η/(mΔt) ⟨φ̇⟩₋^m where ⟨x⟩₋ = max(-x, 0)
                R_phi_penalty = np.zeros(3)
                for i in range(3):
                    phi_dot_i = phi_dot_elem[i]
                    if phi_dot_i < 0:  # Healing attempt (φ decreasing)
                        # Penalty function: η/(mΔt) * (-φ̇)^m
                        penalty_value = self.eta / (self.m * self.dt) * (-phi_dot_i) ** self.m
                        R_phi_penalty[i] = -penalty_value * N[i] * area * weight  # CORRECT residual implementation: NEGATIVE
                
                # Total phase field residual
                R_phi_elem = R_phi_diffusion + R_phi_resistance + R_phi_driving + R_phi_penalty
                
                # =============================================================
                # ASSEMBLY INTO GLOBAL RESIDUAL VECTORS
                # =============================================================
                
                # Global DOF indices for this element
                u_dofs = np.array([2*element[0], 2*element[0]+1, 
                                  2*element[1], 2*element[1]+1, 
                                  2*element[2], 2*element[2]+1], dtype=int)
                phi_dofs = element.astype(int)
                
                # Add element contributions to global residuals
                R_u[u_dofs] += R_u_elem
                R_phi[phi_dofs] += R_phi_elem
        
        return R_u, R_phi
    
    def compute_jacobian(self):
        """Compute Jacobian matrix ∂R/∂x for Newton-Raphson iteration (pure_mechanical.md Section 6)"""
        n_dof_u = 2 * self.n_nodes
        n_dof_phi = self.n_nodes
        total_dof = n_dof_u + n_dof_phi
        
        # Initialize Jacobian matrix
        J = lil_matrix((total_dof, total_dof))
        
        # Gauss points for triangle integration
        gauss_points = [
            (1/6, 1/6, 1/3),      # Point 1
            (2/3, 1/6, 1/3),      # Point 2  
            (1/6, 2/3, 1/3)       # Point 3
        ]
        
        for elem_id, element in enumerate(self.elements):
            element_nodes = self.nodes[element]
            
            # Get B matrices
            B_u, B_phi, det_J = self.compute_B_matrices(element_nodes)
            area = 0.5 * abs(det_J)
            
            # Element phase field values
            phi_elem = self.phi[element]
            phi_old_elem = self.phi_old[element]
            
            # Element displacement
            u_elem = np.zeros(6)
            for i in range(3):
                u_elem[2*i] = self.u[int(2*element[i])]      # ux
                u_elem[2*i+1] = self.u[int(2*element[i]+1)]  # uy
            
            # Compute strain and derived quantities
            strain = B_u @ u_elem
            stress = self.D @ strain
            psi_elem = self.compute_elastic_energy_density(strain)
            
            # Gauss integration
            for xi, eta, weight in gauss_points:
                N, _, _ = self.shape_functions(xi, eta)
                
                # Interpolate phase field at Gauss point
                phi_gp = N.dot(phi_elem)
                
                # Degradation function and its derivative
                g_phi = (1 - phi_gp)**2 + self.k
                dg_dphi = -2 * (1 - phi_gp)  # ∂g/∂φ = -2(1-φ)
                
                # =============================================================
                # JACOBIAN BLOCKS (pure_mechanical.md Section 6, equations 176-178)
                # J = [∂R^u/∂u   ∂R^u/∂φ ]
                #     [∂R^φ/∂u   ∂R^φ/∂φ ]
                # =============================================================
                
                # J_uu: ∂R^u/∂u = ∂/∂u [∫ g(φ) B^T σ dΩ] = ∫ g(φ) B^T D B dΩ
                J_uu_elem = g_phi * B_u.T @ self.D @ B_u * area * weight
                
                # J_uφ: ∂R^u/∂φ = ∂/∂φ [∫ g(φ) B^T σ dΩ] = ∫ (∂g/∂φ) B^T σ N dΩ
                # Note: σ depends on u but not directly on φ
                J_uphi_elem = np.zeros((6, 3))
                for i in range(6):  # displacement DOFs
                    for j in range(3):  # phase field nodes
                        # ∂g/∂φ * (B^T σ)_i * N_j
                        J_uphi_elem[i, j] = dg_dphi * (B_u.T @ stress)[i] * N[j] * area * weight
                
                # J_φu: ∂R^φ/∂u = ∂/∂u [-2ψ(ε) N] = -∂/∂u [2ψ(ε)] N = -2 ∂ψ/∂ε ∂ε/∂u N = -2 σ^T B N
                # Since ψ = ½ε:D:ε, we have ∂ψ/∂ε = D:ε = σ
                # BUT: The driving force term is -2ψ, so ∂(-2ψ)/∂u = -2∂ψ/∂u = -2σ^T B
                # However, we also have the resistance term (Gc/l₀ + 2ψ)φ, so ∂/∂u[2ψφ] = +2σ^T B φ
                # Net effect: ∂R^φ/∂u = +2σ^T B (φ - 1) ≈ +2σ^T B φ for small φ
                J_phiu_elem = np.zeros((3, 6))
                for i in range(3):  # phase field nodes
                    for j in range(6):  # displacement DOFs
                        # +2 * σ^T * B_u * N_i (corrected sign - this is the driving force derivative)
                        stress_B_product = 0
                        for k in range(3):  # stress components
                            stress_B_product += stress[k] * B_u[k, j]
                        phi_at_node = phi_elem[i]  # Phase field value at this node
                        J_phiu_elem[i, j] = 2 * stress_B_product * N[i] * area * weight
                
                # J_φφ: ∂R^φ/∂φ (most complex block)
                J_phiphi_elem = np.zeros((3, 3))
                
                # Term 1: ∂/∂φ [Gc l₀ B^T ∇φ] = Gc l₀ B^T B
                J_phiphi_diffusion = self.Gc * self.l0 * B_phi.T @ B_phi * area * weight
                
                # Term 2: ∂/∂φ [(Gc/l₀ + 2ψ) N φ] = (Gc/l₀ + 2ψ) N^T N
                # Note: ψ depends on u, not φ, so ∂ψ/∂φ = 0
                J_phiphi_resistance = (self.Gc / self.l0 + 2 * psi_elem) * np.outer(N, N) * area * weight
                
                # Term 3: ∂/∂φ [-2ψ N] = 0 (since ψ doesn't depend on φ)
                # No contribution
                
                # Term 4: ∂/∂φ [Penalty terms] - Use consistent penalty derivative
                phi_dot_elem = (phi_elem - phi_old_elem) / self.dt
                J_phiphi_penalty = np.zeros((3, 3))
                for i in range(3):
                    phi_dot_i = phi_dot_elem[i]
                    if phi_dot_i < 0:  # Only when healing is attempted
                        # Use the corrected penalty derivative matching backup_ele.py
                        penalty_deriv = self.penalty_derivative(phi_dot_i)
                        # Apply the derivative with correct time scaling (matching backup_ele.py approach)
                        J_phiphi_penalty[i, i] = penalty_deriv * N[i]**2 * area * weight / self.dt
                
                # Combine all φ-φ terms
                J_phiphi_elem = J_phiphi_diffusion + J_phiphi_resistance - J_phiphi_penalty
                
                # =============================================================
                # ASSEMBLY INTO GLOBAL JACOBIAN MATRIX
                # =============================================================
                
                # Global DOF indices
                u_dofs = np.array([2*element[0], 2*element[0]+1, 
                                  2*element[1], 2*element[1]+1, 
                                  2*element[2], 2*element[2]+1], dtype=int)
                phi_dofs = (n_dof_u + element).astype(int)
                
                # Assemble J_uu block
                for i in range(6):
                    for j in range(6):
                        J[u_dofs[i], u_dofs[j]] += J_uu_elem[i, j]
                
                # Assemble J_uφ block
                for i in range(6):
                    for j in range(3):
                        J[u_dofs[i], phi_dofs[j]] += J_uphi_elem[i, j]
                
                # Assemble J_φu block
                for i in range(3):
                    for j in range(6):
                        J[phi_dofs[i], u_dofs[j]] += J_phiu_elem[i, j]
                
                # Assemble J_φφ block
                for i in range(3):
                    for j in range(3):
                        J[phi_dofs[i], phi_dofs[j]] += J_phiphi_elem[i, j]
        
        return J.tocsr()
    
    def apply_boundary_conditions_residual(self, K, R):
        """Apply boundary conditions to Jacobian and residual for Newton-Raphson
        
        OPTION 3: Constrained DOFs are pre-set before Newton-Raphson iteration.
        Here we just freeze them by:
        1. Setting R[row] = 0 (already satisfied)
        2. Setting K[row,:] = 0, K[row,row] = 1 (identity row)
        3. This ensures delta_x[row] = 0 (no update to constrained DOFs)
        """
        n_dof_u = 2 * self.n_nodes
        
        # Track which DOFs are constrained and store their indices
        constrained_dofs = []
        
        # Bottom boundary: u = 0 (fixed)
        for node in self.bottom_nodes:
            # ux = 0
            row = int(2 * node)
            K[row, :] = 0
            K[row, row] = 1
            R[row] = 0.0  # Already satisfied (pre-set)
            constrained_dofs.append(row)
            
            # uy = 0
            row = int(2 * node + 1)
            K[row, :] = 0
            K[row, row] = 1
            R[row] = 0.0  # Already satisfied (pre-set)
            constrained_dofs.append(row)
        
        # Top boundary: uₓ = prescribed, uᵧ = 0
        for node in self.top_nodes:
            # ux = prescribed displacement
            row = int(2 * node)
            K[row, :] = 0
            K[row, row] = 1
            R[row] = 0.0  # Already satisfied (pre-set)
            constrained_dofs.append(row)
            
            # uy = 0
            row = int(2 * node + 1)
            K[row, :] = 0
            K[row, row] = 1
            R[row] = 0.0  # Already satisfied (pre-set)
            constrained_dofs.append(row)
        
        # Add rigid body constraints
        if len(self.left_nodes) > 0:
            constraint_node = self.left_nodes[len(self.left_nodes)//2]
            if constraint_node not in self.bottom_nodes:
                row = int(2 * constraint_node)
                K[row, :] = 0
                K[row, row] = 1
                R[row] = 0.0  # Already satisfied (pre-set)
                constrained_dofs.append(row)
        
        # Add right boundary constraint
        free_right_nodes = [n for n in self.right_nodes if n not in self.bottom_nodes and n not in self.top_nodes]
        if len(free_right_nodes) > 1:
            constraint_node = free_right_nodes[len(free_right_nodes)//2]
            row = int(2 * constraint_node + 1)  # uy = 0
            K[row, :] = 0
            K[row, row] = 1
            R[row] = 0.0  # Already satisfied (pre-set)
            constrained_dofs.append(row)
        
        # Debug output
        print(f"    Froze {len(constrained_dofs)} displacement DOFs (pre-set boundary conditions)")
        
        return K, R, constrained_dofs

    def solve_system_newton_raphson(self, verbose=False):
        """Solve the coupled system using Newton-Raphson iteration - OPTION 3: Pre-set BCs"""
        if verbose:
            print(f"  Starting Newton-Raphson iteration...")
        
        # CRITICAL FIX: Store previous time step phi for irreversibility, NOT current phi
        # phi_initial = self.phi.copy()  # WRONG - this is current phi
        phi_initial = self.phi_old.copy()  # CORRECT - this is previous time step phi
        
        # PRE-SET BOUNDARY CONDITIONS: Set displacement values BEFORE Newton-Raphson
        # These DOFs will be frozen throughout the iteration
        prescribed_ux = 1e-5 * self.current_time * 1e-3
        
        # Bottom boundary: u = 0 (fixed)
        for node in self.bottom_nodes:
            self.u[2*node] = 0.0      # ux = 0
            self.u[2*node+1] = 0.0    # uy = 0
        
        # Top boundary: ux = prescribed, uy = 0
        for node in self.top_nodes:
            self.u[2*node] = prescribed_ux  # ux = prescribed displacement
            self.u[2*node+1] = 0.0          # uy = 0
        
        # Rigid body constraints
        if len(self.left_nodes) > 0:
            constraint_node = self.left_nodes[len(self.left_nodes)//2]
            if constraint_node not in self.bottom_nodes:
                self.u[2*constraint_node] = 0.0  # ux = 0
        
        free_right_nodes = [n for n in self.right_nodes if n not in self.bottom_nodes and n not in self.top_nodes]
        if len(free_right_nodes) > 1:
            constraint_node = free_right_nodes[len(free_right_nodes)//2]
            self.u[2*constraint_node+1] = 0.0  # uy = 0
        
        if verbose:
            print(f"    Pre-set boundary displacements: top ux = {prescribed_ux*1e6:.6f} μm")
        
        # Newton-Raphson iteration
        for iteration in range(self.max_iterations):
            if verbose:
                print(f"    Iteration {iteration+1}/{self.max_iterations}")
                
            # Compute residuals at current state
            start_time = time.time()
            R_u, R_phi = self.compute_residuals()
            residual_time = time.time() - start_time
            
            # Compute Jacobian matrix
            if verbose and iteration == 0:
                print(f"      Computing Jacobian...")
            jacobian_start = time.time()
            K = self.compute_jacobian()
            jacobian_time = time.time() - jacobian_start
            
            # Apply boundary conditions to Jacobian and residual
            R_combined = np.concatenate([R_u, R_phi])
            K, R_combined, constrained_dofs = self.apply_boundary_conditions_residual(K, R_combined)
            
            # Extract constrained residuals for separate monitoring
            n_dof_u = 2 * self.n_nodes
            R_u_constrained = R_combined[:n_dof_u]
            R_phi_constrained = R_combined[n_dof_u:]
            
            # Check convergence using the constrained residuals
            residual_norm = np.linalg.norm(R_combined)
            R_u_norm = np.linalg.norm(R_u_constrained)
            R_phi_norm = np.linalg.norm(R_phi_constrained)
            
            if verbose:
                print(f"      Residual norm: {residual_norm:.2e} (R_u: {R_u_norm:.2e}, R_phi: {R_phi_norm:.2e})")
                print(f"      Timing: Residual={residual_time:.3f}s, Jacobian={jacobian_time:.3f}s")
                
            # Improved convergence check with both absolute and relative criteria
            solution_norm = np.linalg.norm(np.concatenate([self.u, self.phi]))
            abs_converged = residual_norm < self.tolerance_abs
            rel_converged = residual_norm < self.tolerance_rel * max(solution_norm, 1.0)
            
            if abs_converged or rel_converged:
                if verbose:
                    conv_type = "absolute" if abs_converged else "relative"
                    print(f"    Converged in {iteration+1} iterations ({conv_type})!")
                break
            
            # Debug: Check matrix properties (sparse-friendly)
            if verbose and iteration == 0:
                matrix_nnz = K.nnz
                matrix_density = K.nnz / (K.shape[0] * K.shape[1])
                print(f"      Matrix: {K.shape[0]}x{K.shape[1]}, nnz={matrix_nnz}, density={matrix_density:.2e}")
            
            # Newton update: K * Δx = -R
            try:
                delta_x = spsolve(K, -R_combined)
            except Exception as e:
                print(f"    Error solving Newton system at iteration {iteration+1}: {e}")
                return False
            
            # Check for reasonable update magnitudes and apply damping if needed
            delta_x_norm = np.linalg.norm(delta_x)
            if delta_x_norm > 1e3:  # Safeguard against divergence
                print(f"    Warning: Large Newton update (||Δx|| = {delta_x_norm:.2e}) at iteration {iteration+1}")
                # Apply damping for stability
                delta_x *= 0.1
                if verbose:
                    print(f"    Applied damping factor 0.1")
            
            # Ensure constrained DOFs don't get updated (should already be zero from K*delta_x=-R)
            # This is a safeguard to maintain exact boundary conditions
            for dof in constrained_dofs:
                delta_x[dof] = 0.0
            
            # Update solution: x = x + Δx
            # Constrained DOFs won't change because delta_x[constrained] = 0
            self.u += delta_x[:n_dof_u]
            self.phi += delta_x[n_dof_u:]
            
            # Debug output for first iteration
            if verbose and iteration == 0:
                print(f"      After update: max|u| = {np.max(np.abs(self.u)):.2e} m = {np.max(np.abs(self.u))*1e6:.3f} μm")
                print(f"      delta_x norm: {np.linalg.norm(delta_x[:n_dof_u]):.2e}")
                if len(self.top_nodes) > 0:
                    print(f"      Top node u[0]: {self.u[2*self.top_nodes[0]]:.2e} m = {self.u[2*self.top_nodes[0]]*1e6:.3f} μm")
            
            # REMOVE THE IMMEDIATE CONSTRAINT ENFORCEMENT DURING ITERATION
            # This was causing oscillations - constraints are already handled in the residual
            
        else:
            print(f"    Warning: Newton-Raphson failed to converge in {self.max_iterations} iterations")
            print(f"    Final residual norm: {residual_norm:.2e}")
            return False
        
        # Apply constraints ONLY ONCE after convergence  
        self.phi = np.clip(self.phi, 0, 1)  # Phase field bounds
        # REMOVED: self.phi = np.maximum(phi_initial, self.phi)
        # Irreversibility is already enforced by penalty term during Newton iteration!
        
        # REMOVED: Do NOT apply displacement BCs after convergence!
        # Boundary conditions are already correctly applied during Newton iteration
        # in apply_boundary_conditions_residual() method.
        # Applying them here causes the odd/even oscillation pattern.
        
        return True
    
    def visualize_results(self, step):
        """Visualize current results: displacement magnitude, phase field, and strain energy density"""
        # Save every interval and at the final step
        if step % self.save_interval != 0 and step != self.n_steps:
            return
            
        # Compute strain energy density field
        strain_energy = self.compute_strain_energy_density_field()
        
        fig, axes = plt.subplots(2, 2, figsize=(16, 12))
        
        # Displacement magnitude (match working version exactly)
        u_mag = np.sqrt(self.u[::2]**2 + self.u[1::2]**2)
        im1 = axes[0,0].tripcolor(self.nodes[:, 0]*1e3, self.nodes[:, 1]*1e3, 
                                 self.elements, u_mag*1e6, shading='flat', cmap='viridis')
        axes[0,0].set_title(f'Displacement Magnitude (μm) - Step {step}\nTime: {self.current_time:.2f}s [Newton-Raphson]')
        axes[0,0].set_xlabel('x (mm)')
        axes[0,0].set_ylabel('y (mm)')
        axes[0,0].set_aspect('equal')
        plt.colorbar(im1, ax=axes[0,0], label='μm')
        
        # Phase field
        im2 = axes[0,1].tripcolor(self.nodes[:, 0]*1e3, self.nodes[:, 1]*1e3, 
                                 self.elements, self.phi, shading='flat', cmap='Reds', vmin=0, vmax=1)
        axes[0,1].set_title(f'Phase Field φ - Step {step}\nMax φ: {np.max(self.phi):.6f} [Newton-Raphson]')
        axes[0,1].set_xlabel('x (mm)')
        axes[0,1].set_ylabel('y (mm)')
        axes[0,1].set_aspect('equal')
        plt.colorbar(im2, ax=axes[0,1], label='φ')
        
        # Strain energy density
        strain_energy_log = np.log10(strain_energy + 1e-12)  # Log scale for better visualization
        im3 = axes[1,0].tripcolor(self.nodes[:, 0]*1e3, self.nodes[:, 1]*1e3, 
                                 self.elements, strain_energy_log, shading='flat', cmap='plasma')
        axes[1,0].set_title(f'Strain Energy Density (log₁₀) - Step {step}\nMax: {np.max(strain_energy):.2e} J/m³ [N-R]')
        axes[1,0].set_xlabel('x (mm)')
        axes[1,0].set_ylabel('y (mm)')
        axes[1,0].set_aspect('equal')
        plt.colorbar(im3, ax=axes[1,0], label='log₁₀(J/m³)')
        
        # Combined view: displacement with crack outline (match working version)
        im4 = axes[1,1].tripcolor(self.nodes[:, 0]*1e3, self.nodes[:, 1]*1e3, 
                                 self.elements, u_mag*1e6, shading='flat', cmap='viridis', alpha=0.8)
        # Overlay crack contour
        if np.max(self.phi) > 0.1:
            contour = axes[1,1].tricontour(self.nodes[:, 0]*1e3, self.nodes[:, 1]*1e3, 
                                          self.elements, self.phi, levels=[0.5], colors='red', linewidths=2)
        axes[1,1].set_title(f'Displacement + Crack [Newton-Raphson]\nApplied ux: {self.current_time * 1e-5 * 1e3:.3f} μm')
        axes[1,1].set_xlabel('x (mm)')
        axes[1,1].set_ylabel('y (mm)')
        axes[1,1].set_aspect('equal')
        plt.colorbar(im4, ax=axes[1,1], label='Displacement (μm)')
        
        plt.tight_layout()
        plt.savefig(f'newton_raphson_results_step_{step:04d}_t{self.current_time:04.0f}s.png', dpi=150, bbox_inches='tight')
        plt.close()  # Close figure to save memory instead of showing
        
        # Print detailed statistics
        print(f"  Visualization statistics:")
        print(f"    Max strain energy density: {np.max(strain_energy):.2e} J/m³")
        print(f"    Max displacement magnitude: {np.max(u_mag)*1e6:.6f} μm")  # More precision
        print(f"    Applied displacement: {self.current_time * 1e-5 * 1e3:.6f} μm")  # More precision
        print(f"    Phase field range: [{np.min(self.phi):.6f}, {np.max(self.phi):.6f}]")
        print(f"    Displacement field: min={np.min(self.u):.2e} m, max={np.max(self.u):.2e} m")
        if len(self.top_nodes) > 0:
            print(f"    Top node displacement: ux={self.u[2*self.top_nodes[0]]*1e6:.6f} μm")
    
    def run_simulation(self):
        """Run the complete Newton-Raphson FEM simulation"""
        print("="*70)
        print("STARTING NEWTON-RAPHSON FEM CRACK PROPAGATION SIMULATION")
        print("="*70)
        print(f"Using robust mesh with {self.n_nodes} nodes, {self.n_elements} elements")
        print(f"Initial φ = 0 everywhere (crack void in mesh geometry)")
        print(f"Newton-Raphson: max_iter={self.max_iterations}, tol_abs={self.tolerance_abs}, tol_rel={self.tolerance_rel}")
        print(f"Time step: {self.dt} s")
        print(f"Total time: {self.t_final} s")
        print(f"Number of steps: {self.n_steps}")
        print(f"Saving plots every {self.save_interval} seconds")
        print(f"Boundary conditions:")
        print(f"  - Bottom: u = 0 (fixed)")
        print(f"  - Top: ux = 1×10⁻⁵t mm, uy = 0")
        print(f"  - Left/Right: stress-free + rigid body constraints")
        print("")
        
        # Create output directory
        os.makedirs('newton_raphson_results', exist_ok=True)
        
        start_time = time.time()
        convergence_failures = 0
        
        for step in range(self.n_steps + 1):
            self.current_time = step * self.dt
            
            # Print progress every 10 steps or when saving
            if step % 10 == 0 or step % self.save_interval == 0 or step == self.n_steps:
                progress = step / self.n_steps * 100
                print(f"Step {step}/{self.n_steps} (t = {self.current_time:.0f} s) - {progress:.1f}% complete")
            
            # NOTE: phi_old is NOT updated here! It retains value from previous time step.
            # This is CRITICAL for irreversibility constraint to work correctly.
            
            # Solve coupled system using Newton-Raphson
            # phi_old represents φ^n (previous time step)
            # Newton will find φ^{n+1} subject to φ^{n+1} ≥ φ^n
            step_start = time.time()
            verbose = (step % self.save_interval == 0 or step == self.n_steps)
            success = self.solve_system_newton_raphson(verbose=verbose)
            step_time = time.time() - step_start
            
            if success is False:
                convergence_failures += 1
                print(f"  Newton-Raphson convergence failure at step {step}")
                if convergence_failures > 3:
                    print(f"  Too many convergence failures ({convergence_failures}). Stopping simulation.")
                    break
            
            # CRITICAL FIX: Update phi_old AFTER solving (for next time step)
            # Now phi_old = φ^{n+1} will be used as reference for step n+2
            self.phi_old = self.phi.copy()
            
            # Print timing details only when saving
            if verbose:
                print(f"  Step completed in {step_time:.3f} s")
            
            # Visualize results
            self.visualize_results(step)
            
            # Brief status for non-save steps
            if step % 10 == 0 and step % self.save_interval != 0:
                print("")
        
        total_time = time.time() - start_time
        print("="*70)
        print("NEWTON-RAPHSON SIMULATION COMPLETED")
        print("="*70)
        print(f"Total simulation time: {total_time:.2f} s")
        print(f"Average time per step: {total_time/self.n_steps:.3f} s")
        print(f"Convergence failures: {convergence_failures}")

def main(n_cores=None):
    """
    Main function to run Newton-Raphson FEM crack simulation
    
    Parameters:
    -----------
    n_cores : int, optional
        Number of CPU cores to use for parallel computing.
        If None, auto-detects optimal number.
        Examples: 4, 8, 12, 16, 18
    """
    
    # Check if robust mesh file exists
    mesh_file = 'robust_crack.npz'
    if not os.path.exists(mesh_file):
        print(f"Error: Mesh file '{mesh_file}' not found!")
        print("Please run 'python robust_crack_mesh.py' first to generate the robust mesh.")
        
        # Check for alternative mesh files
        if os.path.exists('simple_crack_mesh.npz'):
            mesh_file = 'simple_crack_mesh.npz'
            print(f"Found alternative mesh: {mesh_file}")
        else:
            return
    
    # Create and run simulation
    print(f"Loading mesh from: {mesh_file}")
    sim = FEMCrackSimulationNewtonRaphson(mesh_file)
    
    # Override core count if specified
    if n_cores is not None and sim.use_parallel:
        sim.n_cores = n_cores
        print(f"Manual override: Using {n_cores} cores")
    
    sim.run_simulation()

if __name__ == "__main__":
    main()

