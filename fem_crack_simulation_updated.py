#!/usr/bin/env python3
"""
Updated FEM Crack Propagation Simulation using Robust Mesh
- Uses robust mesh with pre-defined crack void geometry
- Sets φ = 0 everywhere initially (since crack void is in mesh)
- Adds rigid body constraints to prevent spurious motion
- Implements proper boundary conditions per fem_em.md
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve
import time
import os

class FEMCrackSimulationUpdated:
    def __init__(self, mesh_file='robust_crack.npz'):
        """Initialize FEM crack propagation simulation with robust mesh"""
        
        # Load mesh data
        if mesh_file.endswith('.npz'):
            mesh_data = np.load(mesh_file)
            self.nodes = mesh_data['nodes']
            self.elements = mesh_data['triangles']
        else:
            print(f"Error: Expected .npz file, got {mesh_file}")
            print("Please use the robust mesh generated by robust_crack_mesh.py")
            return
            
        self.n_nodes = len(self.nodes)
        self.n_elements = len(self.elements)
        
        print(f"Loaded robust mesh: {self.n_nodes} nodes, {self.n_elements} elements")
        
        # Material properties (from fem_em.md)
        self.E = 210e9  # Pa (210 GPa)
        self.nu = 0.3   # Poisson's ratio
        self.rho = 7.38e3  # kg/m³
        self.g = 9.81   # m/s²
        
        # Body force (from fem_em.md: ρg = 72.4×10³ N/m³)
        self.body_force = np.array([0, -72.4e3])  # N/m³ downward
        
        # Phase field properties (from fem_em.md)
        self.Gc = 4000  # N/m (fracture energy) - updated value
        self.l0 = 1.25e-5  # m (length scale)
        self.k = 1e-6  # Small regularization parameter
        
        # Penalty method parameters (from fem_em.md)
        self.eta = 4e6  # Penalty parameter
        self.m = 2      # Penalty exponent
        
        # Time parameters
        self.dt = 1.0   # s (time step)  
        self.t_final = 4000.0  # s (final time)
        self.n_steps = int(self.t_final / self.dt)
        self.save_interval = 20  # Save every 5 seconds
        
        # Solution fields
        self.u = np.zeros(2 * self.n_nodes)  # Displacement [ux1, uy1, ux2, uy2, ...]
        self.phi = np.zeros(self.n_nodes)    # Phase field - all zeros since crack void is in mesh
        self.phi_old = np.zeros(self.n_nodes)  # Previous time step phase field
        
        # Initialize phase field (all zeros since crack void is already in mesh geometry)
        self.initialize_phase_field()
        
        # Constitutive matrix (plane strain)
        self.D = self.compute_constitutive_matrix()
        
        # Find boundary nodes
        self.find_boundary_nodes()
        
        print("Updated FEM simulation initialized successfully")
        print(f"Initial phase field: all φ = {np.max(self.phi):.1f} (crack void in mesh geometry)")
        
        # Print critical parameters for crack propagation
        driving_threshold = self.Gc / (2 * self.l0)
        print(f"Critical strain energy density for propagation: {driving_threshold:.2e} J/m³")
        print(f"Material parameters: Gc={self.Gc} N/m, l₀={self.l0*1e6:.1f} μm")
        print(f"Phase field parameters: k={self.k}, η={self.eta:.0e}, m={self.m}")
        print(f"Body force magnitude: {np.linalg.norm(self.body_force):.1e} N/m³")
    
    def compute_constitutive_matrix(self):
        """Compute plane strain constitutive matrix (from fem_em.md)"""
        factor = self.E * (1 - self.nu) / ((1 + self.nu) * (1 - 2 * self.nu))
        D = np.array([
            [1.0, self.nu/(1-self.nu), 0],
            [self.nu/(1-self.nu), 1.0, 0],
            [0, 0, (1-2*self.nu)/(2*(1-self.nu))]
        ]) * factor
        return D
    
    def initialize_phase_field(self):
        """Initialize phase field - all zeros since crack void is in mesh geometry"""
        # Since the crack void is already represented in the mesh geometry,
        # we initialize φ = 0 everywhere (intact material)
        # The crack propagation will be driven by mechanical loading
        self.phi = np.zeros(self.n_nodes)
        self.phi_old = self.phi.copy()
        print("Phase field initialized: φ = 0 everywhere (crack void in mesh geometry)")
    
    def find_boundary_nodes(self):
        """Find boundary nodes for applying boundary conditions"""
        tol = 1e-9
        
        # Find domain boundaries
        self.bottom_nodes = np.where(self.nodes[:, 1] < tol)[0]
        self.top_nodes = np.where(self.nodes[:, 1] > (1e-3 - tol))[0]
        self.left_nodes = np.where(self.nodes[:, 0] < tol)[0]
        self.right_nodes = np.where(self.nodes[:, 0] > (1e-3 - tol))[0]
        
        print(f"Boundary nodes: bottom={len(self.bottom_nodes)}, top={len(self.top_nodes)}, "
              f"left={len(self.left_nodes)}, right={len(self.right_nodes)}")
    
    def shape_functions(self, xi, eta):
        """Linear triangle shape functions and derivatives"""
        N = np.array([1 - xi - eta, xi, eta])
        
        # Shape function derivatives in natural coordinates
        dN_dxi = np.array([-1, 1, 0])
        dN_deta = np.array([-1, 0, 1])
        
        return N, dN_dxi, dN_deta
    
    def compute_B_matrices(self, element_nodes):
        """Compute B matrices for element"""
        # Element coordinates
        x1, y1 = element_nodes[0]
        x2, y2 = element_nodes[1]
        x3, y3 = element_nodes[2]
        
        # Jacobian matrix
        J = np.array([
            [x2 - x1, x3 - x1],
            [y2 - y1, y3 - y1]
        ])
        
        det_J = np.linalg.det(J)
        if abs(det_J) < 1e-12:
            print(f"Warning: Small Jacobian determinant: {det_J}")
            
        J_inv = np.linalg.inv(J)
        
        # Shape function derivatives in physical coordinates
        dN_dx = J_inv @ np.array([[-1, 1, 0], [-1, 0, 1]])
        
        # B matrix for displacement (strain-displacement)
        B_u = np.zeros((3, 6))  # 3 strains, 6 DOFs (2 per node)
        for i in range(3):
            B_u[0, 2*i] = dN_dx[0, i]      # ∂N_i/∂x for εxx
            B_u[1, 2*i+1] = dN_dx[1, i]    # ∂N_i/∂y for εyy
            B_u[2, 2*i] = dN_dx[1, i]      # ∂N_i/∂y for γxy
            B_u[2, 2*i+1] = dN_dx[0, i]    # ∂N_i/∂x for γxy
        
        # B matrix for phase field (gradient)
        B_phi = np.zeros((2, 3))  # 2 gradients, 3 nodes
        B_phi[0, :] = dN_dx[0, :]  # ∂N_i/∂x
        B_phi[1, :] = dN_dx[1, :]  # ∂N_i/∂y
        
        return B_u, B_phi, det_J
    
    def compute_elastic_energy_density(self, strain):
        """Compute positive part of elastic energy density"""
        # Compute stress
        stress = self.D @ strain
        
        # Elastic energy density
        psi = 0.5 * strain @ stress
        
        # Return positive part (for phase field driving force)
        return max(0, psi)
    
    def compute_strain_energy_density_field(self):
        """Compute strain energy density at all nodes"""
        strain_energy = np.zeros(self.n_nodes)
        node_count = np.zeros(self.n_nodes)
        
        for elem_id, element in enumerate(self.elements):
            element_nodes = self.nodes[element]
            
            # Get B matrix
            B_u, _, det_J = self.compute_B_matrices(element_nodes)
            
            # Element displacement
            u_elem = np.zeros(6)
            for i in range(3):
                u_elem[2*i] = self.u[int(2*element[i])]      # ux
                u_elem[2*i+1] = self.u[int(2*element[i]+1)]  # uy
            
            # Compute strain
            strain = B_u @ u_elem
            
            # Elastic energy density
            psi = self.compute_elastic_energy_density(strain)
            
            # Add to nodes (averaging)
            for i in range(3):
                strain_energy[element[i]] += psi
                node_count[element[i]] += 1
        
        # Average strain energy density at nodes
        strain_energy = np.divide(strain_energy, node_count, 
                                out=np.zeros_like(strain_energy), 
                                where=node_count!=0)
        
        return strain_energy
    
    def penalty_function(self, phi_dot):
        """Compute penalty function for irreversibility"""
        if phi_dot < 0:  # Healing attempt
            return self.eta / (self.m * self.dt) * (-phi_dot) ** self.m
        else:
            return 0
    
    def penalty_derivative(self, phi_dot):
        """Derivative of penalty function (matching backup_ele.py working implementation)"""
        if phi_dot < 0:  # Healing attempt
            # Simple working form from backup_ele.py
            return self.eta / self.dt * (-phi_dot) ** (self.m - 1)
        else:
            return 0
    
    def assemble_system_matrix(self):
        """Assemble coupled stiffness matrix and force vector (direct approach like backup_ele.py)"""
        n_dof_u = 2 * self.n_nodes
        n_dof_phi = self.n_nodes
        total_dof = n_dof_u + n_dof_phi
        
        # Initialize matrices
        K = lil_matrix((total_dof, total_dof))
        F = np.zeros(total_dof)
        
        # Gauss points for triangle (3-point integration)
        gauss_points = [
            (1/6, 1/6, 1/3),      # Point 1
            (2/3, 1/6, 1/3),      # Point 2  
            (1/6, 2/3, 1/3)       # Point 3
        ]
        
        for elem_idx, element in enumerate(self.elements):
            element_nodes = self.nodes[element]
            
            # Get B matrices
            B_u, B_phi, det_J = self.compute_B_matrices(element_nodes)
            area = 0.5 * abs(det_J)
            if area < 1e-16:
                continue
            
            # Element phase field values
            phi_elem = self.phi[element]
            phi_old_elem = self.phi_old[element]
            
            # Element displacement
            u_elem = np.zeros(6)
            for i in range(3):
                u_elem[2*i] = self.u[int(2*element[i])]      # ux
                u_elem[2*i+1] = self.u[int(2*element[i]+1)]  # uy
            
            # Compute strain and energy density (element-constant for linear triangles)
            strain = B_u @ u_elem
            psi_elem = self.compute_elastic_energy_density(strain)
            
            # Gauss integration
            for xi, eta, weight in gauss_points:
                N, _, _ = self.shape_functions(xi, eta)
                
                # Interpolate phase field at Gauss point
                phi_gp = N.dot(phi_elem)
                
                # Degradation function g(φ) = (1-φ)² + k
                g_phi = (1 - phi_gp)**2 + self.k
                
                # K_uu: Mechanical stiffness matrix
                K_uu_elem = g_phi * B_u.T @ self.D @ B_u * area * weight
                
                # K_phi_phi: Phase field stiffness matrix
                K_phi_phi_elem = (self.Gc * self.l0 * B_phi.T @ B_phi + 
                                 (self.Gc / self.l0 + 2 * psi_elem) * np.outer(N, N)) * area * weight
                
                # Coupling terms
                K_u_phi_elem = np.zeros((6, 3))
                K_phi_u_elem = np.zeros((3, 6))
                
                dg_dphi = -2 * (1 - phi_gp)  # Derivative of degradation function
                stress = self.D @ strain
                
                # Assembly coupling terms (following backup_ele.py approach)
                for i in range(3):
                    for j in range(3):
                        # K_u_phi: mechanical effect on phase field
                        K_u_phi_elem[2*i, j] += dg_dphi * stress[0] * N[j] * area * weight
                        K_u_phi_elem[2*i+1, j] += dg_dphi * stress[1] * N[j] * area * weight
                        
                        # K_phi_u: phase field effect on mechanics
                        K_phi_u_elem[i, 2*j] += 2 * psi_elem * N[i] * area * weight
                        K_phi_u_elem[i, 2*j+1] += 2 * psi_elem * N[i] * area * weight
                
                # Add penalty terms to K_phi_phi
                for i in range(3):
                    phi_dot = (phi_elem[i] - phi_old_elem[i]) / self.dt
                    penalty_deriv = self.penalty_derivative(phi_dot)
                    K_phi_phi_elem[i, i] += penalty_deriv * area * weight / self.dt
                
                # Global DOF indices
                u_dofs = np.array([2*element[0], 2*element[0]+1, 
                                  2*element[1], 2*element[1]+1, 
                                  2*element[2], 2*element[2]+1], dtype=int)
                phi_dofs = (n_dof_u + element).astype(int)
                
                # Assemble into global matrix
                for i in range(6):
                    for j in range(6):
                        K[u_dofs[i], u_dofs[j]] += K_uu_elem[i, j]
                
                for i in range(3):
                    for j in range(3):
                        K[phi_dofs[i], phi_dofs[j]] += K_phi_phi_elem[i, j]
                
                for i in range(6):
                    for j in range(3):
                        K[u_dofs[i], phi_dofs[j]] += K_u_phi_elem[i, j]
                
                for i in range(3):
                    for j in range(6):
                        K[phi_dofs[i], u_dofs[j]] += K_phi_u_elem[i, j]
                
                # Force vector
                # Mechanical body force
                for i in range(3):
                    F[int(2*element[i])] += self.body_force[0] * N[i] * area * weight
                    F[int(2*element[i]+1)] += self.body_force[1] * N[i] * area * weight
                
                # Phase field driving force
                for i in range(3):
                    # Energy driving force: 2*ψ
                    F[int(n_dof_u + element[i])] += 2 * psi_elem * N[i] * area * weight
                    
                    # Penalty force (irreversibility constraint)
                    phi_dot = (phi_elem[i] - phi_old_elem[i]) / self.dt
                    if phi_dot < 0:  # Only apply penalty for healing attempts
                        penalty_force = self.eta / (self.m * self.dt) * (-phi_dot) ** self.m
                        F[int(n_dof_u + element[i])] -= penalty_force * N[i] * area * weight
        
        return K.tocsr(), F
    
    def apply_boundary_conditions(self, K, F):
        """Apply boundary conditions per fem_em.md"""
        n_dof_u = 2 * self.n_nodes
        
        # Bottom boundary: u = 0 (fixed) - fem_em.md
        for node in self.bottom_nodes:
            # ux = 0
            row = int(2 * node)
            K[row, :] = 0
            K[row, row] = 1
            F[row] = 0
            
            # uy = 0
            row = int(2 * node + 1)
            K[row, :] = 0
            K[row, row] = 1
            F[row] = 0
        
        # Top boundary: uₓ = 1×10⁻⁵t mm, uᵧ = 0 - fem_em.md
        current_time = self.current_time
        prescribed_ux = 1e-5 * current_time * 1e-3  # Convert mm to m
        
        for node in self.top_nodes:
            # ux = prescribed displacement
            row = int(2 * node)
            K[row, :] = 0
            K[row, row] = 1
            F[row] = prescribed_ux
            
            # uy = 0
            row = int(2 * node + 1)
            K[row, :] = 0
            K[row, row] = 1
            F[row] = 0
        
        # Add rigid body constraints to prevent spurious motion
        # Constraint 1: Fix one point completely (already done with bottom boundary)
        
        # Constraint 2: Prevent rotation - fix x-displacement of one left boundary node
        if len(self.left_nodes) > 0:
            constraint_node = self.left_nodes[len(self.left_nodes)//2]  # Middle left node
            if constraint_node not in self.bottom_nodes:  # Avoid double constraint
                row = int(2 * constraint_node)  # ux = 0
                K[row, :] = 0
                K[row, row] = 1
                F[row] = 0
        
        # Constraint 3: Prevent rigid body translation in y - constrain middle right node
        # This is ESSENTIAL to prevent under-constrained system (per backup_ele.py analysis)
        free_right_nodes = [n for n in self.right_nodes if n not in self.bottom_nodes and n not in self.top_nodes]
        if len(free_right_nodes) > 1:
            # Add constraint: fix y-displacement of middle right node
            constraint_node = free_right_nodes[len(free_right_nodes)//2]
            row = int(2 * constraint_node + 1)  # uy = 0
            K[row, :] = 0
            K[row, row] = 1
            F[row] = 0
        
        return K, F
    
    def compute_residuals(self):
        """Compute residual vectors R_u and R_phi according to pure_mechanical.md Section 4"""
        n_dof_u = 2 * self.n_nodes
        n_dof_phi = self.n_nodes
        
        # Initialize residuals
        R_u = np.zeros(n_dof_u)
        R_phi = np.zeros(n_dof_phi)
        
        # Gauss points for triangle (3-point integration per pure_mechanical.md)
        gauss_points = [
            (1/6, 1/6, 1/3),      # Point 1
            (2/3, 1/6, 1/3),      # Point 2  
            (1/6, 2/3, 1/3)       # Point 3
        ]
        
        for elem_id, element in enumerate(self.elements):
            element_nodes = self.nodes[element]
            
            # Get B matrices
            B_u, B_phi, det_J = self.compute_B_matrices(element_nodes)
            area = 0.5 * abs(det_J)
            
            # Element phase field values
            phi_elem = self.phi[element]
            phi_old_elem = self.phi_old[element]
            
            # Element displacement DOF vector
            u_elem = np.zeros(6)
            for i in range(3):
                u_elem[2*i] = self.u[int(2*element[i])]      # ux
                u_elem[2*i+1] = self.u[int(2*element[i]+1)]  # uy
            
            # Compute strain (constant over linear triangle)
            strain = B_u @ u_elem
            
            # Compute stress σ = D:ε (plain stress tensor)
            stress = self.D @ strain
            
            # Compute positive elastic energy density ψ = ½ε:D:ε (per pure_mechanical.md line 227)
            psi_elem = self.compute_elastic_energy_density(strain)
            
            # Gauss integration over element
            for xi, eta, weight in gauss_points:
                N, _, _ = self.shape_functions(xi, eta)
                
                # Interpolate phase field at Gauss point
                phi_gp = N.dot(phi_elem)
                
                # Degradation function g(φ) = (1-φ)² + k (per pure_mechanical.md line 64)
                g_phi = (1 - phi_gp)**2 + self.k
                
                # =============================================================
                # MECHANICAL RESIDUAL (pure_mechanical.md Section 4.1)
                # R^u = ∫_Ω g(φ)σ:∇δu dΩ - ∫_Ω b·δu dΩ = 0
                # Discretized: R^u = ∫_Ω g(φ)(B^u)^T σ dΩ - ∫_Ω N^T b dΩ
                # =============================================================
                
                # Internal force contribution: ∫ g(φ) B^T σ dΩ
                R_u_internal = g_phi * B_u.T @ stress * area * weight
                
                # Body force contribution: ∫ N^T b dΩ (pure_mechanical.md line 67)
                # b = [0, -72.4×10³] N/m³
                R_u_body = np.zeros(6)
                for i in range(3):  # For each node in element
                    R_u_body[2*i] = self.body_force[0] * N[i] * area * weight      # x-component
                    R_u_body[2*i+1] = self.body_force[1] * N[i] * area * weight    # y-component
                
                # Mechanical residual: R^u = Internal - External
                R_u_elem = R_u_internal - R_u_body
                
                # =============================================================
                # PHASE FIELD RESIDUAL (pure_mechanical.md Section 4.2)
                # R^φ = ∫_Ω {Gc l₀ ∇φ·∇δφ + [Gc/l₀ + 2ψ(ε)] φδφ - 2ψ(ε)δφ + P(φ̇)δφ} dΩ = 0
                # Discretized form per equation 86 in pure_mechanical.md
                # =============================================================
                
                # Phase field gradient at current state
                phi_grad = B_phi @ phi_elem
                
                # Phase field time derivative (for penalty method)
                phi_dot_elem = (phi_elem - phi_old_elem) / self.dt
                
                # Term 1: Gc l₀ ∇φ·∇δφ → Gc l₀ (B^φ)^T ∇φ
                R_phi_diffusion = self.Gc * self.l0 * B_phi.T @ phi_grad * area * weight
                
                # Term 2: [Gc/l₀ + 2ψ(ε)] φδφ → [Gc/l₀ + 2ψ(ε)] N^T φ
                # This is the resistance term that opposes crack growth
                phi_at_gauss = N @ phi_elem  # φ interpolated to Gauss point
                R_phi_resistance = (self.Gc / self.l0 + 2 * psi_elem) * N * phi_at_gauss * area * weight
                
                # Term 3: -2ψ(ε)δφ → -2ψ(ε) N (driving force)
                # This is the driving force that promotes crack growth when ψ > Gc/(2l₀)
                R_phi_driving = -2 * psi_elem * N * area * weight
                
                # Term 4: Penalty term P(φ̇) for irreversibility (pure_mechanical.md lines 95-98)
                # P(φ̇) = η/(mΔt) ⟨φ̇⟩₋^m where ⟨x⟩₋ = max(-x, 0)
                R_phi_penalty = np.zeros(3)
                for i in range(3):
                    phi_dot_i = phi_dot_elem[i]
                    if phi_dot_i < 0:  # Healing attempt (φ decreasing)
                        # Penalty function: η/(mΔt) * (-φ̇)^m
                        penalty_value = self.eta / (self.m * self.dt) * (-phi_dot_i) ** self.m
                        R_phi_penalty[i] = penalty_value * N[i] * area * weight
                
                # Total phase field residual
                R_phi_elem = R_phi_diffusion + R_phi_resistance + R_phi_driving + R_phi_penalty
                
                # =============================================================
                # ASSEMBLY INTO GLOBAL RESIDUAL VECTORS
                # =============================================================
                
                # Global DOF indices for this element
                u_dofs = np.array([2*element[0], 2*element[0]+1, 
                                  2*element[1], 2*element[1]+1, 
                                  2*element[2], 2*element[2]+1], dtype=int)
                phi_dofs = element.astype(int)
                
                # Add element contributions to global residuals
                R_u[u_dofs] += R_u_elem
                R_phi[phi_dofs] += R_phi_elem
        
        return R_u, R_phi
    
    def compute_jacobian(self):
        """Compute Jacobian matrix ∂R/∂x for Newton-Raphson iteration (pure_mechanical.md Section 6)"""
        n_dof_u = 2 * self.n_nodes
        n_dof_phi = self.n_nodes
        total_dof = n_dof_u + n_dof_phi
        
        # Initialize Jacobian matrix
        J = lil_matrix((total_dof, total_dof))
        
        # Gauss points for triangle integration
        gauss_points = [
            (1/6, 1/6, 1/3),      # Point 1
            (2/3, 1/6, 1/3),      # Point 2  
            (1/6, 2/3, 1/3)       # Point 3
        ]
        
        for elem_id, element in enumerate(self.elements):
            element_nodes = self.nodes[element]
            
            # Get B matrices
            B_u, B_phi, det_J = self.compute_B_matrices(element_nodes)
            area = 0.5 * abs(det_J)
            
            # Element phase field values
            phi_elem = self.phi[element]
            phi_old_elem = self.phi_old[element]
            
            # Element displacement
            u_elem = np.zeros(6)
            for i in range(3):
                u_elem[2*i] = self.u[int(2*element[i])]      # ux
                u_elem[2*i+1] = self.u[int(2*element[i]+1)]  # uy
            
            # Compute strain and derived quantities
            strain = B_u @ u_elem
            stress = self.D @ strain
            psi_elem = self.compute_elastic_energy_density(strain)
            
            # Gauss integration
            for xi, eta, weight in gauss_points:
                N, _, _ = self.shape_functions(xi, eta)
                
                # Interpolate phase field at Gauss point
                phi_gp = N.dot(phi_elem)
                
                # Degradation function and its derivative
                g_phi = (1 - phi_gp)**2 + self.k
                dg_dphi = -2 * (1 - phi_gp)  # ∂g/∂φ = -2(1-φ)
                
                # =============================================================
                # JACOBIAN BLOCKS (pure_mechanical.md Section 6, equations 176-178)
                # J = [∂R^u/∂u   ∂R^u/∂φ ]
                #     [∂R^φ/∂u   ∂R^φ/∂φ ]
                # =============================================================
                
                # J_uu: ∂R^u/∂u = ∂/∂u [∫ g(φ) B^T σ dΩ] = ∫ g(φ) B^T D B dΩ
                J_uu_elem = g_phi * B_u.T @ self.D @ B_u * area * weight
                
                # J_uφ: ∂R^u/∂φ = ∂/∂φ [∫ g(φ) B^T σ dΩ] = ∫ (∂g/∂φ) B^T σ N dΩ
                # Note: σ depends on u but not directly on φ
                J_uphi_elem = np.zeros((6, 3))
                for i in range(6):  # displacement DOFs
                    for j in range(3):  # phase field nodes
                        # ∂g/∂φ * (B^T σ)_i * N_j
                        J_uphi_elem[i, j] = dg_dphi * (B_u.T @ stress)[i] * N[j] * area * weight
                
                # J_φu: ∂R^φ/∂u = ∂/∂u [-2ψ(ε) N] = -∂/∂u [2ψ(ε)] N = -2 ∂ψ/∂ε ∂ε/∂u N = -2 σ^T B N
                # Since ψ = ½ε:D:ε, we have ∂ψ/∂ε = D:ε = σ
                # BUT: The driving force term is -2ψ, so ∂(-2ψ)/∂u = -2∂ψ/∂u = -2σ^T B
                # However, we also have the resistance term (Gc/l₀ + 2ψ)φ, so ∂/∂u[2ψφ] = +2σ^T B φ
                # Net effect: ∂R^φ/∂u = +2σ^T B (φ - 1) ≈ +2σ^T B φ for small φ
                J_phiu_elem = np.zeros((3, 6))
                for i in range(3):  # phase field nodes
                    for j in range(6):  # displacement DOFs
                        # +2 * σ^T * B_u * N_i (corrected sign - this is the driving force derivative)
                        stress_B_product = 0
                        for k in range(3):  # stress components
                            stress_B_product += stress[k] * B_u[k, j]
                        phi_at_node = phi_elem[i]  # Phase field value at this node
                        J_phiu_elem[i, j] = 2 * stress_B_product * N[i] * area * weight
                
                # J_φφ: ∂R^φ/∂φ (most complex block)
                J_phiphi_elem = np.zeros((3, 3))
                
                # Term 1: ∂/∂φ [Gc l₀ B^T ∇φ] = Gc l₀ B^T B
                J_phiphi_diffusion = self.Gc * self.l0 * B_phi.T @ B_phi * area * weight
                
                # Term 2: ∂/∂φ [(Gc/l₀ + 2ψ) N φ] = (Gc/l₀ + 2ψ) N^T N
                # Note: ψ depends on u, not φ, so ∂ψ/∂φ = 0
                J_phiphi_resistance = (self.Gc / self.l0 + 2 * psi_elem) * np.outer(N, N) * area * weight
                
                # Term 3: ∂/∂φ [-2ψ N] = 0 (since ψ doesn't depend on φ)
                # No contribution
                
                # Term 4: ∂/∂φ [Penalty terms] - Use consistent penalty derivative
                phi_dot_elem = (phi_elem - phi_old_elem) / self.dt
                J_phiphi_penalty = np.zeros((3, 3))
                for i in range(3):
                    phi_dot_i = phi_dot_elem[i]
                    if phi_dot_i < 0:  # Only when healing is attempted
                        # Use the corrected penalty derivative matching backup_ele.py
                        penalty_deriv = self.penalty_derivative(phi_dot_i)
                        # Apply the derivative with correct time scaling (matching backup_ele.py approach)
                        J_phiphi_penalty[i, i] = penalty_deriv * N[i]**2 * area * weight / self.dt
                
                # Combine all φ-φ terms
                J_phiphi_elem = J_phiphi_diffusion + J_phiphi_resistance + J_phiphi_penalty
                
                # =============================================================
                # ASSEMBLY INTO GLOBAL JACOBIAN MATRIX
                # =============================================================
                
                # Global DOF indices
                u_dofs = np.array([2*element[0], 2*element[0]+1, 
                                  2*element[1], 2*element[1]+1, 
                                  2*element[2], 2*element[2]+1], dtype=int)
                phi_dofs = (n_dof_u + element).astype(int)
                
                # Assemble J_uu block
                for i in range(6):
                    for j in range(6):
                        J[u_dofs[i], u_dofs[j]] += J_uu_elem[i, j]
                
                # Assemble J_uφ block
                for i in range(6):
                    for j in range(3):
                        J[u_dofs[i], phi_dofs[j]] += J_uphi_elem[i, j]
                
                # Assemble J_φu block
                for i in range(3):
                    for j in range(6):
                        J[phi_dofs[i], u_dofs[j]] += J_phiu_elem[i, j]
                
                # Assemble J_φφ block
                for i in range(3):
                    for j in range(3):
                        J[phi_dofs[i], phi_dofs[j]] += J_phiphi_elem[i, j]
        
        return J.tocsr()
    
    def apply_boundary_conditions_residual(self, K, R):
        """Apply boundary conditions to Jacobian and residual"""
        n_dof_u = 2 * self.n_nodes
        
        # Bottom boundary: u = 0 (fixed) - use proper residual form
        for node in self.bottom_nodes:
            # ux = 0
            row = int(2 * node)
            K[row, :] = 0
            K[row, row] = 1
            R[row] = self.u[row] - 0.0  # Residual form: current_value - prescribed_value
            
            # uy = 0
            row = int(2 * node + 1)
            K[row, :] = 0
            K[row, row] = 1
            R[row] = self.u[row] - 0.0  # Residual form: current_value - prescribed_value
        
        # Top boundary: uₓ = 1×10⁻⁵t mm, uᵧ = 0
        prescribed_ux = 1e-5 * self.current_time * 1e-3  # Convert mm to m
        
        for node in self.top_nodes:
            # ux = prescribed displacement
            row = int(2 * node)
            K[row, :] = 0
            K[row, row] = 1
            R[row] = self.u[row] - prescribed_ux  # Residual form
            
            # uy = 0
            row = int(2 * node + 1)
            K[row, :] = 0
            K[row, row] = 1
            R[row] = self.u[row]  # Residual form
        
        # Add rigid body constraints
        if len(self.left_nodes) > 0:
            constraint_node = self.left_nodes[len(self.left_nodes)//2]
            if constraint_node not in self.bottom_nodes:
                row = int(2 * constraint_node)
                K[row, :] = 0
                K[row, row] = 1
                R[row] = self.u[row] - 0.0  # Residual form: current_value - prescribed_value
        
        # Add right boundary constraint (essential for preventing under-constrained system)
        free_right_nodes = [n for n in self.right_nodes if n not in self.bottom_nodes and n not in self.top_nodes]
        if len(free_right_nodes) > 1:
            constraint_node = free_right_nodes[len(free_right_nodes)//2]
            row = int(2 * constraint_node + 1)  # uy = 0
            K[row, :] = 0
            K[row, row] = 1
            R[row] = self.u[row] - 0.0  # Residual form
        
        return K, R
    

    def solve_system(self, verbose=False):
        """Solve the coupled system using direct stiffness matrix approach (like backup_ele.py)"""
        if verbose:
            print(f"  Solving coupled mechanical-phase field system...")
        
        # Assemble system matrix and force vector using proven approach
        K, F = self.assemble_system_matrix()
        
        # Apply boundary conditions
        K, F = self.apply_boundary_conditions(K, F)
        
        # Solve coupled system directly (like backup_ele.py)
        try:
            solution = spsolve(K, F)
        except Exception as e:
            print(f"    Error solving coupled system: {e}")
            return False
            
        # Extract solutions
        n_dof_u = 2 * self.n_nodes
        self.u = solution[:n_dof_u]
        phi_new = solution[n_dof_u:]
            
        # Update phase field with bounds and irreversibility (like backup_ele.py)
        self.phi_old = self.phi.copy()
        phi_new = np.clip(phi_new, 0, 1)  # Phase field bounds
            
        # Enforce irreversibility: φ can only increase
        self.phi = np.maximum(self.phi, phi_new)
        
        # Print statistics only when verbose
        if verbose:
            max_u = np.max(np.abs(self.u))
            max_phi = np.max(self.phi)
            min_phi = np.min(self.phi)
            crack_area = np.sum(self.phi > 0.1) / self.n_nodes
            
            # Compute max strain energy density to understand driving forces
            strain_energy = self.compute_strain_energy_density_field()
            max_psi = np.max(strain_energy)
            driving_threshold = self.Gc / (2 * self.l0)  # Critical ψ for propagation
            
            print(f"    Max displacement: {max_u*1e6:.3f} μm")
            print(f"    Phase field range: [{min_phi:.6f}, {max_phi:.6f}]")
            print(f"    Crack area fraction: {crack_area:.4f}")
            print(f"    Max strain energy density: {max_psi:.2e} J/m³")
            print(f"    Critical threshold for propagation: {driving_threshold:.2e} J/m³")
            print(f"    Energy ratio (ψ_max/ψ_critical): {max_psi/driving_threshold:.3f}")
            print(f"    Crack should propagate: {max_psi > driving_threshold}")
            
        return True
    
    def visualize_results(self, step):
        """Visualize current results: displacement magnitude, phase field, and strain energy density"""
        # Save every 5 seconds (5 steps) and at the final step
        if step % self.save_interval != 0 and step != self.n_steps:
            return
            
        # Compute strain energy density field
        strain_energy = self.compute_strain_energy_density_field()
        
        fig, axes = plt.subplots(2, 2, figsize=(16, 12))
        
        # Displacement magnitude
        u_mag = np.sqrt(self.u[::2]**2 + self.u[1::2]**2)
        im1 = axes[0,0].tripcolor(self.nodes[:, 0]*1e3, self.nodes[:, 1]*1e3, 
                                 self.elements, u_mag*1e6, shading='flat', cmap='viridis')
        axes[0,0].set_title(f'Displacement Magnitude (μm) - Step {step}\nTime: {self.current_time:.2f}s')
        axes[0,0].set_xlabel('x (mm)')
        axes[0,0].set_ylabel('y (mm)')
        axes[0,0].set_aspect('equal')
        plt.colorbar(im1, ax=axes[0,0], label='μm')
        
        # Phase field
        im2 = axes[0,1].tripcolor(self.nodes[:, 0]*1e3, self.nodes[:, 1]*1e3, 
                                 self.elements, self.phi, shading='flat', cmap='Reds', vmin=0, vmax=1)
        axes[0,1].set_title(f'Phase Field φ - Step {step}\nMax φ: {np.max(self.phi):.6f}')
        axes[0,1].set_xlabel('x (mm)')
        axes[0,1].set_ylabel('y (mm)')
        axes[0,1].set_aspect('equal')
        plt.colorbar(im2, ax=axes[0,1], label='φ')
        
        # Strain energy density
        strain_energy_log = np.log10(strain_energy + 1e-12)  # Log scale for better visualization
        im3 = axes[1,0].tripcolor(self.nodes[:, 0]*1e3, self.nodes[:, 1]*1e3, 
                                 self.elements, strain_energy_log, shading='flat', cmap='plasma')
        axes[1,0].set_title(f'Strain Energy Density (log₁₀) - Step {step}\nMax: {np.max(strain_energy):.2e} J/m³')
        axes[1,0].set_xlabel('x (mm)')
        axes[1,0].set_ylabel('y (mm)')
        axes[1,0].set_aspect('equal')
        plt.colorbar(im3, ax=axes[1,0], label='log₁₀(J/m³)')
        
        # Combined view: displacement with crack outline
        im4 = axes[1,1].tripcolor(self.nodes[:, 0]*1e3, self.nodes[:, 1]*1e3, 
                                 self.elements, u_mag*1e6, shading='flat', cmap='viridis', alpha=0.8)
        # Overlay crack contour
        if np.max(self.phi) > 0.1:
            contour = axes[1,1].tricontour(self.nodes[:, 0]*1e3, self.nodes[:, 1]*1e3, 
                                          self.elements, self.phi, levels=[0.5], colors='red', linewidths=2)
        axes[1,1].set_title(f'Displacement + Crack\nApplied ux: {self.current_time * 1e-5 * 1e3:.3f} μm')
        axes[1,1].set_xlabel('x (mm)')
        axes[1,1].set_ylabel('y (mm)')
        axes[1,1].set_aspect('equal')
        plt.colorbar(im4, ax=axes[1,1], label='Displacement (μm)')
        
        plt.tight_layout()
        plt.savefig(f'fem_results_step_{step:04d}_t{self.current_time:04.0f}s.png', dpi=150, bbox_inches='tight')
        plt.close()  # Close figure to save memory instead of showing
        
        # Print detailed statistics
        print(f"  Visualization statistics:")
        print(f"    Max strain energy density: {np.max(strain_energy):.2e} J/m³")
        print(f"    Max displacement magnitude: {np.max(u_mag)*1e6:.3f} μm")
        print(f"    Applied displacement: {self.current_time * 1e-5 * 1e3:.3f} μm")
        print(f"    Phase field range: [{np.min(self.phi):.6f}, {np.max(self.phi):.6f}]")
    
    def run_simulation(self):
        """Run the complete FEM simulation"""
        print("="*70)
        print("STARTING UPDATED FEM CRACK PROPAGATION SIMULATION")
        print("="*70)
        print(f"Using robust mesh with {self.n_nodes} nodes, {self.n_elements} elements")
        print(f"Initial φ = 0 everywhere (crack void in mesh geometry)")
        print(f"Time step: {self.dt} s")
        print(f"Total time: {self.t_final} s")
        print(f"Number of steps: {self.n_steps}")
        print(f"Saving plots every {self.save_interval} seconds")
        print(f"Boundary conditions:")
        print(f"  - Bottom: u = 0 (fixed)")
        print(f"  - Top: ux = 1×10⁻⁵t mm, uy = 0")
        print(f"  - Left/Right: stress-free + rigid body constraints")
        print("")
        
        # Create output directory
        os.makedirs('fem_results', exist_ok=True)
        
        start_time = time.time()
        
        for step in range(self.n_steps + 1):
            self.current_time = step * self.dt
            
            # Print progress every 100 steps or when saving
            if step % 100 == 0 or step % self.save_interval == 0 or step == self.n_steps:
                progress = step / self.n_steps * 100
                print(f"Step {step}/{self.n_steps} (t = {self.current_time:.0f} s) - {progress:.1f}% complete")
            
            # Update phase field history at the beginning of time step
            if step > 0:  # Skip first step (initial condition)
                self.phi_old = self.phi.copy()
            
            # Solve coupled system
            step_start = time.time()
            verbose = (step % self.save_interval == 0 or step == self.n_steps)
            success = self.solve_system(verbose=verbose)
            step_time = time.time() - step_start
            
            if success is False:
                print(f"  Solution failed at step {step}")
                break
            
            # Print timing details only when saving
            if verbose:
                print(f"  Step completed in {step_time:.3f} s")
            
            # Visualize results (saves every 5 seconds)
            self.visualize_results(step)
            
            # Brief status for non-save steps
            if step % 100 == 0 and step % self.save_interval != 0:
                print("")
        
        total_time = time.time() - start_time
        print("="*70)
        print("SIMULATION COMPLETED")
        print("="*70)
        print(f"Total simulation time: {total_time:.2f} s")
        print(f"Average time per step: {total_time/self.n_steps:.3f} s")

def main():
    """Main function to run updated FEM crack simulation"""
    
    # Check if robust mesh file exists
    mesh_file = 'robust_crack.npz'
    if not os.path.exists(mesh_file):
        print(f"Error: Mesh file '{mesh_file}' not found!")
        print("Please run 'python robust_crack_mesh.py' first to generate the robust mesh.")
        
        # Check for alternative mesh files
        if os.path.exists('simple_crack_mesh.npz'):
            mesh_file = 'simple_crack_mesh.npz'
            print(f"Found alternative mesh: {mesh_file}")
        else:
            return
    
    # Create and run simulation
    print(f"Loading mesh from: {mesh_file}")
    sim = FEMCrackSimulationUpdated(mesh_file)
    sim.run_simulation()

if __name__ == "__main__":
    main()